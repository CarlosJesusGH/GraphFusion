# -*- coding: utf-8 -*-
"""bsc - nmfif py re-write

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n4ModNgX449-k2SRWFqQjYk5flvuve6Q

### imports
"""

import numpy as np
import h5py
import time
import random
import sys

# TODO: delete seed
np.random.seed(0)
random.seed(0)

"""### factor class"""

objectives = []

class factor():
  # def __init__(str, m, n, initMode): pass;

  # def addGraphRegularizer(double* reg,double lambda=1.0): pass;
  # def addGraphRegularizer(): pass;
  # def addL2Regularizer(plambda=1.0): pass; # double lambda=1.0
  # def addObjective(o, pos): pass; # objective* o,unsigned int pos

  # def step(): pass;

  # def randomInitializer(): pass;
  # def svdInitializer(): pass;
  # def initialiseWeights(): pass;
  def initialiseDerivatives(self):
    self.derivativeNumerator.fill(0); 
    self.derivativeDenominator.fill(0);

  def getNumRows(self): return self.numRows;
  def getNumCols(self): return self.numCols;
  def getWeights(self): return self.weights;
  # def getMemPtr(): return  weights.memptr();

  # def writeToFile(): pass;

  

  # ----------------------

  #include "factor.h"

  # factor::factor(const std::string &str, unsigned int m, unsigned int n, const std::string &initMode)
  def __init__(self, pstr, m, n, initMode):
    # print("factor ini:", pstr, m, n)

    # declare instance variables
    # self.name = "";
    # self.initializer = "";
    # self.weights = "";
    # self.numRows = 0;
    # self.numCols = 0;
    self.graphRegularizer = 0;
    self.l2Regularizer = 0;
    # self.regularizer = np.zeros((1,1)); # arma::mat
    # self.derivativeNumerator = np.zeros((1,1)); # arma::mat
    # self.derivativeDenominator = np.zeros((1,1)); # arma::mat
    self.Os = []  # objectives Os;
    self.factorPositions = []; # std::vector<unsigned int>
    self.numObjectives = 0; # unsigned int 

    # set instance variables with parameters
    self.name = pstr;
    self.numRows = m;
    self.numCols = n;
    # weights = arma::mat(m,n,arma::fill::zeros);
    self.weights = np.zeros((m,n))
    self.initializer = initMode;
    # derivativeNumerator.set_size(numRows,numCols);
    self.derivativeNumerator = np.zeros((self.numRows, self.numCols))
    # derivativeDenominator.set_size(numRows,numCols);
    self.derivativeDenominator = np.zeros((self.numRows, self.numCols))


  # void factor::addObjective(objective* o, unsigned int pos)
  def addObjective(self, o, pos):
    
    # Os.push_back(o);
    self.Os.append(o)
    # factorPositions.push_back(pos);
    self.factorPositions.append(pos);
    # print("factor.addObjective:", o, pos, self, self.factorPositions)
    # numObjectives = Os.size();
    self.numObjectives = len(self.Os)

  # void factor::addGraphRegularizer(double *reg,double lambda)
  def addGraphRegularizer(self, reg, plambda=1.0):
    self.graphRegularizer = plambda;
    # regularizer = arma::mat(reg,numRows,numRows,false);
    self.regularizer = reg # TODO: maybe is necessary to make a copy() here, check later

  # void factor::addL2Regularizer(double lambda)
  def addL2Regularizer(self, plambda=1.0):
      self.l2Regularizer = plambda;

  # void factor::writeToFile()
  def writeToFile(self):
    # weights.save(arma::hdf5_name(name,"dataset",arma::hdf5_opts::trans));
    # with h5py.File(self.name, "w") as data_file:
    #   data_file.create_dataset("dataset", data= self.weights)
    # print("type(self.weights)", type(self.weights))
    np.savetxt(self.name + ".csv", self.weights, delimiter="\t")

  # void factor::randomInitializer()
  def randomInitializer(self):
    # weights.randu(); 
    # print(self.name, "before initialize\n", self.weights)
    # self.weights = np.random.rand(*self.weights.shape)  # this change the reference of the variable for a new one
    self.weights.fill(0);
    self.weights += np.random.rand(*self.weights.shape)
    self.weights += 1e-9;
    # print(self.name, "after initialize\n", self.weights)

  # void factor::svdInitializer()
  def svdInitializer(self):
    self.weights.fill(0);
    # for (unsigned int i; i < Os.size(); ++i )
    for i in range(len(self.Os)):
      # Os[i]->getNNSVD(factorPositions[i],weights);
      self.Os[i].getNNSVD(self.factorPositions[i], self.weights)
    self.weights /= len(self.Os) # Os.size(); 
    self.weights += 1e-9;

  # void factor::initialiseWeights()
  def initialiseWeights(self):
    # if (initializer.compare("tsvd") == 0)
    if self.initializer == "tsvd":
      self.svdInitializer();
    # else if (initializer.compare("random") == 0)
    elif self.initializer == "random":
      self.randomInitializer();
    else:
      print("Initializer unsupported, choose one of {tsvd,random}")

  # void factor::step()
  def step(self):
      # print("factor.step:", self.name, self.factorPositions)
      # print(self.derivativeNumerator)
      self.initialiseDerivatives();
      # print(self.derivativeNumerator)

      j = 0;
      # for (objectives::iterator O=Os.begin(); O!=Os.end();++O)
      for O in self.Os:
        p = self.factorPositions[j];
        # if self.name == "./fact_H": print("factor.step:", self.name, self.derivativeNumerator[1,:])
        # (*O)->computeLossDerivatives(p,derivativeNumerator,derivativeDenominator);
        O.computeLossDerivatives(p, self.derivativeNumerator, self.derivativeDenominator);
        # if self.name == "./fact_H": print("factor.step:", self.name, self.derivativeNumerator[1,:])
        # ++j;
        j+=1

      if (self.l2Regularizer > 0): 
        # derivativeDenominator += (l2Regularizer * weights);
        self.derivativeDenominator += (self.l2Regularizer * self.weights);

      if (self.graphRegularizer > 0):
        # derivativeNumerator += (graphRegularizer *  regularizer * weights);
        self.derivativeNumerator += (self.graphRegularizer * self.regularizer @ self.weights);
        # derivativeDenominator += (graphRegularizer *  arma::diagmat(arma::sum(regularizer,1)) * weights);
        self.derivativeDenominator += (self.graphRegularizer *  np.diag(self.regularizer.sum(axis=1)) @ self.weights);

      # weights %= (derivativeNumerator + 1e-9)/(derivativeDenominator + 1e-9);
      # if self.name == "./fact_H": print("weights update 1/2\n", self.name, self.weights)
      # print(self.derivativeNumerator)
      # print("numerator\n", self.derivativeNumerator, "denominator\n", self.derivativeDenominator)
      # self.weights %= (self.derivativeNumerator + 1e-9) / (self.derivativeDenominator + 1e-9);
      # self.weights = np.multiply(self.weights, (self.derivativeNumerator + 1e-9) / (self.derivativeDenominator + 1e-9));
      self.weights *= (self.derivativeNumerator + 1e-9) / (self.derivativeDenominator + 1e-9);
      # if self.name == "./fact_H": print("weights update 2/2\n", self.name, self.weights)

"""### integration class"""

#ifndef NMTF_INTEGRATION_H
#define NMTF_INTEGRATION_H

#include "factor.h"
#include "nmfobjective.h"
#include "nmtfobjective.h"
#include "snmtfobjective.h"
#include "snmfobjective.h"

class integration():
  # integration() {}
  # integration(objectives &o_list, factors &f_list): Os(o_list), Fs(f_list), numObjectives(o_list.size()), numFactors(f_list.size()) {}
  def __init__(self, o_list, f_list): 
    self.Os = o_list
    self.Fs = f_list
    self.numObjectives = len(o_list)
    self.numFactors = len(f_list)

  # void optimize(const unsigned int max_iter, double threshold, const std::string &filename);
  # def optimize(max_iter, threshold, filename): pass;
  # def computeLoss(): pass;

  # objectives Os;
  # factors Fs;
  # Os = []
  # Fs = []
  # numObjectives = 0;
  # numFactors = 0;

  # -------------------------------

  #include "integration.h"
  #include <algorithm>
  #include <random>

  # void integration::optimize(const unsigned int max_iter, double threshold, const std::string &filename)
  def optimize(self, max_iter, threshold, filename):
    # for (factors::reverse_iterator F=Fs.rbegin(); F!=Fs.rend();++F)
    for F in reversed(self.Fs):
      # (*F)->initialiseWeights();
      F.initialiseWeights();

    # arma::mat storeLosses(numObjectives,(int)(max_iter),arma::fill::zeros);
    storeLosses = np.zeros((self.numObjectives, max_iter))
    # for (unsigned int i=0; i<max_iter; ++i){
    for i in range(max_iter):
      # float start = omp_get_wtime();
      start = time.time()
      # std::random_shuffle(Fs.begin(),Fs.end());
      random.shuffle(self.Fs)
      # for (factors::reverse_iterator F=Fs.rbegin(); F!=Fs.rend();++F)
      for F in reversed(self.Fs):
        # (*F)->step();
        F.step()
      print("Losses:")
      j=0;
      # for (objectives::iterator O=Os.begin(); O!=Os.end(); ++O)
      for O in self.Os:
        O.computeLoss();
        storeLosses[j,i] = O.getLoss();
        print(" ", storeLosses[j,i])
        j+=1 # ++j;
        # print("\n")
      if (i > 0):
        # double jn = arma::accu(storeLosses(arma::span::all,i-1));
        jn = storeLosses[:,i-1].sum()
        # double delta = (jn-arma::accu(storeLosses(arma::span::all,i)))/jn;
        delta = (jn-storeLosses[:,i].sum())/jn;
        # if (delta < threshold && delta > 0)
        if delta < threshold and delta > 0:
          print("Early stop at iteration ", i, " with delta ", delta, "\n")
          break;

        print("\tIteration ", i+1, "/", max_iter, " completed in ", time.time() - start, " seconds. (delta =",delta,")\n")

    # storeLosses.save(arma::hdf5_name(filename,"dataset",arma::hdf5_opts::trans));
    # with h5py.File(filename + ".h5", "w") as data_file:
    #   data_file.create_dataset("dataset", data= storeLosses)
    # store in numpy format
    np.save(filename + ".npy", storeLosses)
    
    # // cgh 2021-04-23: add the factor writing to file step
    # for (factors::reverse_iterator F=Fs.rbegin(); F!=Fs.rend();++F)
    for F in reversed(self.Fs):
      F.writeToFile();

    return storeLosses


  # double integration::computeLoss()
  def computeLoss(self):
    score = 0.0;
    # for (objectives::iterator O=Os.begin(); O!=Os.end(); ++O)
    for O in self.Os:
      # (*O)->computeLoss();
      O.computeLoss();
      # score += (*O)->getLoss();
      score += O.getLoss();
    return score;

"""### objective class"""

# %debug
# class factor:
#     pass

class objective():

  # Fs = [];
  # X = np.zeros((1,1)) # arma::mat
  # lossScore = 0 # double
  # L = np.zeros((1,1)) # arma::mat 
  # s = np.zeros((1,1)) # arma::vec 
  # R = np.zeros((1,1)) # arma::mat 
  # scaler = 1.0;

  # def __init__(self, target, targetSize, compute_svd, k, scalar=1.0):
  #     scaler = scalar;
  #     if (compute_svd):
  #         arma::svds(L,s,R,arma::sp_mat(X),k);
  #         matricesSVDInitialization()
  #         checkSVD(k);
  
  # def __init__(target, targetSize, p, q, r, scalar=1.0):
  #     scaler = scalar;
  #     L = p; s = q; R = r;
  #     checkSVD(std::max((int)L.n_cols,(int)R.n_cols));

  def __init__(self, target, targetSize, initializer=None, k=None, scalar=1.0):
    # X(arma::mat(target,targetSize(0),targetSize(1),false)
    # print("super objective class init")
    self.X = target
    self.scaler = scalar;
    self.lossScore = 0
    # print("initializer", initializer)
    if initializer == "tsvd":
      print("inside objective - svd initializer, k=", k)
      # arma::svds(L,s,R,arma::sp_mat(X),k);
      self.L, self.s, self.R = matricesSVDInitializationOneRelation(self.X, k, k) # TODO: change later k for k1 and k2
      self.checkSVD(k);
  
  # def __init__(target, targetSize, pathL, pathS, pathR, scalar=1.0):
  #   self.Fs = [];
  #   self.scaler = scalar;
  #   self.lossScore = 0
  #   self.L = np.load(pathL)
  #   self.R = np.load(pathR)
  #   self.s = np.load(pathS)

  # def checkSVD(std::max((int)L.n_cols,(int)R.n_cols));
  # def checkSVD(param = max(L.shape[1],R.shape[1])): pass

  # void objective::checkSVD(int k)
  def checkSVD(self, k):
    self.completeMatrix(self.L,k);
    self.completeMatrix(self.R,k);
    self.completeVector(self.s,k);

  # def computeLossDerivatives(): pass
  # def computeLossDerivatives(): pass
  # def computeLoss(): pass
  def getLoss(self):  return self.lossScore; 

  # def getSVDNMF(): pass
  # def getNNSVD(): pass
  # def checkSVD(): pass

  #include "objective.h"

  def nnsvd(self, M, N):
    # for (int i=0; i< M.shape[1];++i):
    for i in range(M.shape[1]):
      # arma::mat pos = arma::max(N.col(i),M.col(i));
      # arma::mat neg = arma::max(-N.col(i),M.col(i));
      # pos = max(N[:,i], M[:,i])
      # neg = max(-N[:,i], M[:,i])
      # print(M.shape, N.shape)
      pos = np.maximum(N[:,i], M[:,i])
      neg = np.maximum(-N[:,i], M[:,i])

      # if (arma::norm(pos) > arma::norm(neg)) 
      if np.linalg.norm(pos) > np.linalg.norm(neg):
        # M.col(i) = pos;
        M[:,i] = pos
      else:
        # M.col(i) = neg;
        M[:,i] = neg
  

  # void objective::getNNSVD(unsigned int ind, arma::mat &G)
  def getNNSVD(self, ind, G):
      # int k = G.n_cols;
      k = G.shape[1]
      # arma::mat temp = arma::zeros(arma::size(G));
      temp = np.zeros(G.shape)
      # print("temp.shape:", temp.shape)
      # arma::mat T;
      # T = None
      # switch (ind)
      # case 0:
      if ind == 0:
          # T = L(arma::span::all,arma::span(0,k-1)) * arma::diagmat(arma::sqrt(s(arma::span(0,k-1))));
          # T = self.L[:,0:k-1] * np.diag(np.sqrt(self.s[0:k-1]))
          # print("ind 0:", self.L[:,0:k].shape, np.diag(np.sqrt(self.s[0:k])).shape)
          # print("self.s", self.s)
          T = self.L[:,0:k] * np.diag(np.sqrt(self.s[0:k]))
          # T = np.dot(self.L[:,0:k], np.diag(np.sqrt(self.s[0:k])))
          # print("T.shape, temp.shape:", T.shape, temp.shape)
          self.nnsvd(temp, T);
          G += temp;
          # break;
      # case 1:
      elif ind == 1:
          # G += arma::eye(arma::size(G));
          G += np.eye(*G.shape)
          # break;
      # case 2:
      elif ind == 2:
          # T = R(arma::span::all,arma::span(0,k-1)) * arma::diagmat(arma::sqrt(s(arma::span(0,k-1))));
          # T = self.R[:,0:k-1] * np.diag(np.sqrt(self.s[0:k-1]))
          # print("ind 2:", self.R[:,0:k].shape, np.diag(np.sqrt(self.s[0:k])).shape)
          # print("self.s", self.s)
          T = self.R[:,0:k] * np.diag(np.sqrt(self.s[0:k]))
          # print("T.shape, temp.shape:", T.shape, temp.shape)
          # from IPython.core.debugger import Pdb; Pdb().set_trace()
          self.nnsvd(temp,T);
          G += temp;
          # break;

  # void completeMatrix(arma::mat &M, int k)
  def completeMatrix(self, M, k):
      # int i = k - (int)M.n_cols;
      i = k - M.shape[1]
      if (i > 0):
        # M.insert_cols((int)M.n_cols,i);
        np.c_[ M, np.zeros((M.shape[0],i))]  

  # void completeVector(arma::vec &v, int k)
  def completeVector(self, v, k):
      # int i = k - (int)v.n_elem;
      i = k - len(v)
      if (i > 0):
        # v.insert_cols((int)v.n_elem,i
        v = np.insert(v, len(v), np.zeros(i))

### svd initialization
# methods from: https://gitlab.bsc.es/czambran/sweet-spot-for-therapeutic-intervention-for-covid-19/-/blob/master/scripts/Data/creatingMatrices.py

def restrictSVD(X, J,K,L, k1, k2):
    """
    Restrics the component of the SVD (X = JKL) to the number of columns needed
    
    Parameters
    ----------
    X: numpy array
       containing the decomposed matrix
    J: numpy array
       containing the first factor of the decomposition
    K: numpy array
       containing the middle factor of the decomposition
    L: numpy array
       containing the last factor of the decomposition
    k1: integer
        Indicates the number of cluster for the viral proteins
    k2: integer
        Indicates the number of cluster for the genes
    s: integer
       seed for the randomization 
        
    Return
    ------
    Returns the restricted factors.
    
    """
        
    epsilon = 1e-5
    n, m = X.shape        

    
    J = J[:n, :k1]
    U = np.where(J > 0., J, epsilon)

    S = np.full((k1,k2), epsilon)
    for i in range(min(k1, k2)):
        S[i][i] = K[i]
        
    L = L[:m, :k2]
    V = np.where(L > 0., L/3., epsilon)[:m, :k2]

    return U,S,V

def matricesSVDInitialization(r12, r23, k1, k2, k3):
    """
    Inizialize the matrices with SVD decomposition
    
    Parameters
    ----------
    r12: pandas DataFrame
         Relational matrix between viral proteins and genes
    r23: pandas DataFrame
         Relational matrix between genes and drugs
    k1: integer
        Indicates the number of cluster for the viral proteins
    k2: integer
        Indicates the number of cluster for the genes
    k3: integer
        Indicates the number of cluster for the drugs
        
    Return
    ------
    Returns the matrices g1, g2, g3, h12 and h23 initializated with the SVD.
    
    """
    
    if r12.shape[1] != r23.shape[0]:
        return 'Matrix R12 must have same number of columns that rows in R23.'
    

    g1,h12,g21 = np.linalg.svd(r12) 
    g1,h12,g21 = restrictSVD(r12, g1, h12, g21, k1, k2)
    
    g22,h23,g3 = np.linalg.svd(r23) 
    g22,h23,g3 = restrictSVD(r23, g22, h23, g3, k2, k3)
    
    g2 = g22+g21/2
    
    return g1, g2, g3, h12, h23

def matricesSVDInitializationOneRelation(r23, k2, k3):
    """
    Inizialize the matrices with SVD decomposition
    
    Parameters
    ----------
    r23: pandas DataFrame
         Relational matrix
    k2: integer
        Indicates the number of cluster for the first component
    k3: integer
        Indicates the number of cluster for the second compoent
        
    Return
    ------
    Returns the matrices initializated with the SVD.
    
    """

    g2,h23,g3 = np.linalg.svd(r23) 
    g2,h23,g3 = restrictSVD(r23, g2, h23, g3, k2, k3)

    
    # return g2, g3, h23
    return g2,h23,g3

# ---

"""#### nmtfObjective class"""

#include "factor.h"
#include "factor.h"

class nmtfObjective(objective):
  # def __init__(double * , const arma::SizeMat &, factor*, factor*, factor*, bool = false,double scalar=1.0);
  # def __init__(double * , const arma::SizeMat &, factor*, factor*, factor*, arma::mat &, arma::mat &, arma::mat &,double scalar=1.0);
  # def __init__(double * , const arma::SizeMat &, factor*, factor*, factor*, std::string, std::string, std::string,double scalar=1.0);

  # def computeLoss(): pass;
  # def computeLossDerivatives(): pass;

  
  # U, V, W = np.zeros((1,1)), np.zeros((1,1)), np.zeros((1,1)) # arma::mat

  # ----------------------------------

  #include "nmtfobjective.h"

  # nmtfObjective::nmtfObjective(double* target, const arma::SizeMat &size, factor *u, factor *v, factor *w, bool compute_svd, double scalar) :
  #     objective(target, size, compute_svd, std::max(u->getNumCols(),w->getNumCols()), scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false)),
  #     W(arma::mat(w->getMemPtr(),w->getNumRows(),w->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  #     w->addObjective(this,2);
  # }

  # nmtfObjective::nmtfObjective(double* target, const arma::SizeMat &size, factor *u, factor *v, factor *w, arma::mat &p, arma::mat &q, arma::mat &r, double scalar) :
  #     objective(target, size, p, q, r, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  #     w->addObjective(this,2);
  # }

  # nmtfObjective::nmtfObjective(double* target, const arma::SizeMat &size, factor *u, factor *v, factor *w, std::string pathL, std::string pathS, std::string pathR, double scalar) :
  #     objective(target, size, pathL, pathR, pathS, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  #     w->addObjective(this,2);
  # }

  def __init__(self, target, size, u, v, w, initializer=None, scalar=1.0):
    """
    from: https://stackoverflow.com/questions/19205916/how-to-call-base-classs-init-method-from-the-child-class
    class BaseClass(object):
    def __init__(self, *args, **kwargs):
        pass
    class ChildClass(BaseClass):
        def __init__(self, *args, **kwargs):
            super(ChildClass, self).__init__(*args, **kwargs)
    """
    # print("u.getNumCols(), w.getNumCols():", u.getNumCols(), w.getNumCols())
    # k = std::max(u->getNumCols(),w->getNumCols())
    k = max(u.getNumCols(), w.getNumCols())
    super().__init__(target, size, initializer, k, scalar)
    # print("nmtfObj.ini:", u.name, u.factorPositions, v.name, v.factorPositions, w.name, w.factorPositions)
    u.addObjective(self,0)
    v.addObjective(self,1)
    w.addObjective(self,2)
    # print("nmtfObj.ini:", u.name, u.factorPositions, v.name, v.factorPositions, w.name, w.factorPositions)
    self.U, self.V, self.W = u.getWeights(), v.getWeights(), w.getWeights()


  # void nmtfObjective::computeLoss()
  def computeLoss(self):
    # lossScore = scaler * arma::norm(X - U * V * W.t(), "fro");
    self.lossScore = self.scaler * np.linalg.norm(self.X - self.U @ self.V @ self.W.transpose(), ord="fro");

  # void nmtfObjective::computeLossDerivatives(unsigned int factorPosition,arma::mat &derivativeNumerator, arma::mat &derivativeDenominator)
  def computeLossDerivatives(self, factorPosition, derivativeNumerator, derivativeDenominator):
    # print(derivativeNumerator.shape, derivativeDenominator.shape, "\n", self.X.shape, self.U.shape, self.V.shape, self.W.shape)
    # switch (factorPosition)
    # case 0:
    if factorPosition == 0:
      temp = self.W @ self.V.transpose(); # print(temp.shape)
      derivativeNumerator += self.scaler * (self.X @ temp);
      derivativeDenominator += self.scaler * (self.U @ temp.transpose() @ temp);
      # break;
    # case 1: 
    elif factorPosition == 1:
      temp = self.U.transpose(); # print(temp.shape)
      derivativeNumerator += self.scaler * (temp @ self.X @ self.W);
      derivativeDenominator += self.scaler * (temp @ self.U @ self.V @ self.W.transpose() @ self.W);
      # break;
    # case 2:
    elif factorPosition == 2:
      temp = self.U @ self.V; # print(temp.shape)
      derivativeNumerator += self.scaler * (self.X.transpose() @ temp);
      # // derivativeDenominator += scaler * (V * temp.t() * temp);
      derivativeDenominator += self.scaler * (self.W @ temp.transpose() @ temp);
      # break;

"""#### nmfObjective class"""

#ifndef NMFOBJECTIVE_H
#define NMFOBJECTIVE_H

#include "factor.h"

class nmfObjective(objective):
  # public:
  #     nmfObjective() {}
  #     nmfObjective(double *target, const arma::SizeMat &size, factor*, factor*, bool = false,double scalar=1.0);
  #     nmfObjective(double *target, const arma::SizeMat &size, factor*, factor*, arma::mat &, arma::mat &, arma::mat &,double scalar=1.0);
  #     nmfObjective(double *target, const arma::SizeMat &size, factor*, factor*, std::string, std::string, std::string,double scalar=1.0);
  #     ~nmfObjective() {}

  #     void computeLoss();
  #     void computeLossDerivatives(unsigned int, arma::mat&, arma::mat&);
  # private:
  #     arma::mat U, V;

#endif // NMFOBJECTIVE_H

# ----------------------------------

#include "nmfobjective.h"

# nmfObjective::nmfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, bool compute_svd, double scalar) :
#     objective(target, size,compute_svd,std::max(u->getNumCols(),v->getNumCols()), scalar),
#     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
#     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
# {
#     u->addObjective(this,0);
#     v->addObjective(this,1);
# }

# nmfObjective::nmfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, arma::mat &p, arma::mat &q, arma::mat &r, double scalar) :
#     objective(target, size, p, q, r, scalar),
#     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
#     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
# {
#     u->addObjective(this,0);
#     v->addObjective(this,1);
# }

# nmfObjective::nmfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, std::string pathL, std::string pathS, std::string pathR, double scalar) :
#     objective(target, size, pathL, pathR, pathS, scalar),
#     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
#     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
# {
#     u->addObjective(this,0);
#     v->addObjective(this,1);
# }

  def __init__(self, target, size, u, v, initializer=None, scalar=1.0):
    # k = std::max(u->getNumCols(),v->getNumCols())
    # print("u.getNumCols(), v.getNumCols():", u.getNumCols(), v.getNumCols())
    k = max(u.getNumCols(), v.getNumCols())
    super().__init__(target, size, initializer, k, scalar)
    u.addObjective(self,0)
    v.addObjective(self,1)
    self.U, self.V = u.getWeights(), v.getWeights()
    

  # void nmfObjective::computeLoss()
  def computeLoss(self):
    # lossScore = scaler * arma::norm(X - U * V.t(), "fro");
    self.lossScore = self.scaler * np.linalg.norm(self.X - self.U @ self.V.transpose(), ord="fro");

  # void nmfObjective::computeLossDerivatives(unsigned int factorPosition, arma::mat &derivativeNumerator, arma::mat &derivativeDenominator)
  def computeLossDerivatives(self, factorPosition, derivativeNumerator, derivativeDenominator):
    # switch (factorPosition)
    # case 0:
    if factorPosition == 0:
      derivativeNumerator += self.scaler * (self.X @ self.V);
      derivativeDenominator += self.scaler * (self.U @ self.V.transpose() @ self.V);
    # case 2: 
    elif factorPosition == 1:
      derivativeNumerator += self.scaler * (self.X.transpose() @ self.U);
      derivativeDenominator += self.scaler * (self.V @ self.U.transpose() @ self.U);

"""#### snmfObjective class"""

#ifndef SNMFOBJECTIVE_H
#define SNMFOBJECTIVE_H

#include "factor.h"

class snmfObjective(objective):
  # public:
  #     snmfObjective() {}
  #     snmfObjective(double *target, const arma::SizeMat &size, factor*, bool = false,double scalar=1.0);
  #     snmfObjective(double *target, const arma::SizeMat &size, factor*, arma::mat &, arma::mat &, arma::mat &,double scalar=1.0);
  #     snmfObjective(double *target, const arma::SizeMat &size, factor*, std::string, std::string, std::string,double scalar=1.0);
  #     ~snmfObjective() {}

  #     void computeLoss();
  #     void computeLossDerivatives(unsigned int, arma::mat&, arma::mat&);
  # private:
  #     arma::mat U, V;

  # endif // SNMFOBJECTIVE_H

# ----------------------------------------------------

  #include "snmfobjective.h"

  # snmfObjective::snmfObjective(double* target, const arma::SizeMat &size, factor* u, bool compute_svd, double scalar) :
  #     objective(target, size,compute_svd,u->getNumCols(), scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  # }

  # snmfObjective::snmfObjective(double* target, const arma::SizeMat &size, factor* u, arma::mat &p, arma::mat &q, arma::mat &r, double scalar) :
  #     objective(target, size, p, q, r, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  # }

  # snmfObjective::snmfObjective(double* target, const arma::SizeMat &size, factor* u, std::string pathL, std::string pathS, std::string pathR, double scalar) :
  #     objective(target, size, pathL, pathR, pathS, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  # }

  def __init__(self, target, size, u, initializer=None, scalar=1.0):
    # k = std::max(u->getNumCols(),v->getNumCols())
    k = u.getNumCols() #max(u.getNumCols(), v.getNumCols())
    super().__init__(target, size, initializer, k, scalar)
    u.addObjective(self,0)
    self.U= u.getWeights()

  # void nmfObjective::computeLoss()
  def computeLoss(self):
    # lossScore = scaler * arma::norm(X - U * U.t(), "fro");
    self.lossScore = self.scaler * np.linalg.norm(self.X - self.U @ self.U.transpose(), ord="fro");

  # void nmfObjective::computeLossDerivatives(unsigned int factorPosition, arma::mat &derivativeNumerator, arma::mat &derivativeDenominator)
  def computeLossDerivatives(self, factorPosition, derivativeNumerator, derivativeDenominator):
    derivativeNumerator += self.scaler * (self.X @ self.U);
    derivativeDenominator += self.scaler * (self.U @ self.U.transpose() @ self.U);

"""#### snmtfObjective class"""

#ifndef SNMTFOBJECTIVE_H
#define SNMTFOBJECTIVE_H

#include "factor.h"

class snmtfObjective(objective):
  # public:
  #     snmtfObjective() {}
  #     snmtfObjective(double *target, const arma::SizeMat &size, factor*, factor*, bool = false,double scalar=1.0);
  #     snmtfObjective(double *target, const arma::SizeMat &size, factor*, factor*, arma::mat &, arma::mat &, arma::mat &,double scalar=1.0);
  #     snmtfObjective(double *target, const arma::SizeMat &size, factor*, factor*, std::string, std::string, std::string,double scalar=1.0);
  #     ~snmtfObjective() {}

  #     void computeLoss();
  #     void computeLossDerivatives(unsigned int, arma::mat &, arma::mat &);
  # private:
  #     arma::mat U, V;

  #endif // SNMTFOBJECTIVE_H

# --------------------------------

  #include "snmtfobjective.h"

  # snmtfObjective::snmtfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, bool compute_svd, double scalar) :
  #     objective(target, size,compute_svd,std::max(u->getNumCols(),v->getNumCols()), scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  # }

  # snmtfObjective::snmtfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, arma::mat &p, arma::mat &q, arma::mat &r, double scalar) :
  #     objective(target, size, p, q, r, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  # }

  # snmtfObjective::snmtfObjective(double* target, const arma::SizeMat &size, factor* u, factor* v, std::string pathL, std::string pathS, std::string pathR, double scalar) :
  #     objective(target, size, pathL, pathR, pathS, scalar),
  #     U(arma::mat(u->getMemPtr(),u->getNumRows(),u->getNumCols(),false)),
  #     V(arma::mat(v->getMemPtr(),v->getNumRows(),v->getNumCols(),false))
  # {
  #     u->addObjective(this,0);
  #     v->addObjective(this,1);
  # }

  def __init__(self, target, size, u, v, initializer=None, scalar=1.0):
    # k = std::max(u->getNumCols(),v->getNumCols())
    k = max(u.getNumCols(), v.getNumCols())
    super().__init__(target, size, initializer, k, scalar)
    u.addObjective(self,0)
    v.addObjective(self,1)
    self.U, self.V = u.getWeights(), v.getWeights()

  # void nmfObjective::computeLoss()
  def computeLoss(self):
    # lossScore = scaler * arma::norm(X - U * V * U.t(), "fro");
    self.lossScore = self.scaler * np.linalg.norm(self.X - self.U @ self.V @ self.U.transpose(), ord="fro");

  # void nmfObjective::computeLossDerivatives(unsigned int factorPosition, arma::mat &derivativeNumerator, arma::mat &derivativeDenominator)
  def computeLossDerivatives(self, factorPosition, derivativeNumerator, derivativeDenominator):
    # switch (factorPosition)
    # case 0:
    if factorPosition == 0:
      derivativeNumerator += self.scaler * (self.X @ self.U @ (self.V + self.V.transpose()));
      derivativeDenominator += self.scaler * (self.U @ self.V @ self.U.transpose() @ self.U @ (self.V + self.V.transpose()));
    # case 1: 
    elif factorPosition == 1:
      temp = self.U.transpose() @ self.U;
      derivativeNumerator = self.scaler * (self.U.transpose() @ self.X @ self.U);
      derivativeDenominator += self.scaler * (temp @ self.V @ temp);



"""*********************************************"""
"""## main"""
"""*********************************************"""

import os
import pickle
# if not os.path.exists("./data"):
#   !git clone https://github.com/tgaudelet/nmfif.git
#   !cp -r /content/nmfif/examples/data .

# class PyNmf:
#   def __init__(self, operational_dir, facts):
#     self.operational_dir = operational_dir
#     self.facts = facts

def execute_nmf(facts, max_iter, delta_min):
  start = time.time()
  # // Reading files in, mind that C++ assumes column-major format which does not always correspond to how the data was generated.
  # // Check that the matrix read is as you expect, the option arma::hdf5_opts::trans perform transposition if it isn't
  # arma::mat X; X.load(arma::hdf5_name("../examples/data/test_333_948","dataset",arma::hdf5_opts::trans));

  all_objectives = []
  all_factors = []
  shared_fact = None

  for fact_id, fact in enumerate(facts):
    print("for fact:", fact)
    # with h5py.File("./graphs/" + fact["M0"], "r") as f:
    #   X = np.array(f.get('dataset'))
    X = np.loadtxt(open("./graphs/" + fact["M0"], "rb"), delimiter="\t", skiprows=0)

    m1c = fact["M1C"] if "M1C" in  fact.keys() else None
    m3c = fact["M3C"] if "M3C" in  fact.keys() else None

    if m1c:
      # with h5py.File("./graphs/" + m1c, "r") as f:
      #   M1C = np.array(f.get('dataset'))
      M1C = np.loadtxt(open("./graphs/" + m1c, "rb"), delimiter="\t", skiprows=0)
    if m3c:
      # with h5py.File("./graphs/" + m3c, "r") as f:
      #   M3C = np.array(f.get('dataset'))
      M3C = np.loadtxt(open("./graphs/" + m3c, "rb"), delimiter="\t", skiprows=0)

    # print("type(X)", type(X))
    n1 = X.shape[0]
    n2 = X.shape[1]
    ks = list(map(int, fact["M2Ks"].split()))
    print("n1, n2, ks:", n1, ", ", n2, ", ", ks)

    # initializer = "random";
    # initializer = "tsvd"
    initializer = fact["initType"]
    factType = fact["factType"]
    print("initializer, factType:", initializer, ",  ", factType)

    m1s = fact["M1S"] if "M1S" in  fact.keys() else None
    m3s = fact["M3S"] if "M3S" in  fact.keys() else None
    print("m1s, m3s:", m1s, m3s)
    # starting from here it will change depending on the type of factorization
    # """****************************"""
    if factType == "SNMF":
      k = ks[0]
      # // We first create all the factors and add them to a list
      if m1s == "up" or m1s == "updown":
        F = shared_fact
      else:
        F = factor("fact_F_" + str(fact_id), n1, k, initializer); 
        if m1c:
          F.addGraphRegularizer(M1C, 1.0);
        all_factors.append(F)
      # G = factor("fact_G_" + str(f_id), n2, k, initializer); all_factors.append(G)
      print("Factors initialized in ", time.time() - start)

      # // We then initialize the different objectives and add them to a list
      O = snmfObjective(X, X.shape, F, initializer); all_objectives.append(O)
      fact["M1_name"] = F.name + ".csv"
    # """****************************"""
    elif factType == "NMF":
      k = ks[0]
      # // We first create all the factors and add them to a list
      if m1s == "up" or m1s == "updown":
        F = shared_fact
      else:
        F = factor("fact_F_" + str(fact_id), n1, k, initializer); 
        if m1c:
          F.addGraphRegularizer(M1C, 1.0);
        all_factors.append(F)
      if m3s == "up" or m3s == "updown":
        G = shared_fact
      else:
        G = factor("fact_G_" + str(fact_id), n2, k, initializer); 
        if m3c:
          G.addGraphRegularizer(M3C, 1.0);
        all_factors.append(G)
      print("Factors initialized in ", time.time() - start)

      # // We then initialize the different objectives and add them to a list
      O = nmfObjective(X, X.shape, F, G, initializer); all_objectives.append(O)
      fact["M1_name"] = F.name + ".csv"
      fact["M3_name"] = G.name + ".csv"
    # """****************************"""
    elif factType == "SNMTF":
      k1, k2 = ks[0], ks[0]
      # // We first create all the factors and add them to a list
      if m3s == "up" or m3s == "updown":
        G = shared_fact
      else:
        G = factor("fact_G_" + str(fact_id), n1, k1, initializer); 
        if m3c:
          G.addGraphRegularizer(M3C, 1.0);
        all_factors.append(G)
      # G = factor("fact_G_" + str(f_id), n2, k, initializer); all_factors.append(G)
      S = factor("fact_S_" + str(fact_id), k1, k2, initializer); all_factors.append(S)
      print("Factors initialized in ", time.time() - start)
      # // We then initialize the different objectives and add them to a list
      # O = snmtfObjective(X, X.shape, F, G, initializer); all_objectives.append(O)
      O = snmtfObjective(X, X.shape, G, S, initializer); all_objectives.append(O)
      fact["M2_name"] = S.name + ".csv"
      fact["M3_name"] = G.name + ".csv"
    # """****************************"""
    elif factType == "SNMTF_old":
      k1, k2 = ks[0], ks[0]
      # // We first create all the factors and add them to a list
      if m1s == "up" or m1s == "updown":
        F = shared_fact
      else:
        F = factor("fact_F_" + str(fact_id), n1, k1, initializer); 
        if m1c:
          F.addGraphRegularizer(M1C, 1.0);
        all_factors.append(F)
      # G = factor("fact_G_" + str(f_id), n2, k, initializer); all_factors.append(G)
      S = factor("fact_S_" + str(fact_id), k1, k2, initializer); all_factors.append(S)
      print("Factors initialized in ", time.time() - start)
      # // We then initialize the different objectives and add them to a list
      # O = snmtfObjective(X, X.shape, F, G, initializer); all_objectives.append(O)
      O = snmtfObjective(X, X.shape, F, S, initializer); all_objectives.append(O)
    # """****************************"""
    elif factType == "NMTF":
      k1, k2 = ks[0], ks[1]
      # // We first create all the factors and add them to a list
      if m1s == "up" or m1s == "updown":
        F = shared_fact
      else:
        F = factor("fact_F_" + str(fact_id), n1, k1, initializer); 
        if m1c:
          F.addGraphRegularizer(M1C, 1.0)
        all_factors.append(F)
      S = factor("fact_S_" + str(fact_id), k1, k2, initializer); all_factors.append(S)
      if m3s == "up" or m3s == "updown":
        G = shared_fact
      else:
        G = factor("fact_G_" + str(fact_id), n2, k2, initializer); 
        if m3c:
          G.addGraphRegularizer(M3C, 1.0);
        all_factors.append(G)
      print("Factors initialized in ", time.time() - start)
      # // We then initialize the different objectives and add them to a list
      # O = snmtfObjective(X, X.shape, F, G, initializer); all_objectives.append(O)
      O = nmtfObjective(X, X.shape, F, S, G, initializer); all_objectives.append(O)
      fact["M1_name"] = F.name + ".csv"
      fact["M2_name"] = S.name + ".csv"
      fact["M3_name"] = G.name + ".csv"
    # """****************************"""
    # now let's work with the factor sharing
    # shared_fact = None
    if m1s == "down" or m1s == "updown":
      F.name = F.name + "_fshared"
      shared_fact = F
      fact["M1_name"] = F.name + ".csv"
    if m3s == "down" or m3s == "updown":
      G.name = G.name + "_gshared"
      shared_fact = G
      fact["M3_name"] = G.name + ".csv"
    
    

  print("Objectives initialized in ", time.time() - start)
  # TODO: add graph regularizer as a factor/matrix
  # F.addGraphRegularizer(A, 1.0);

  # // Finally we create an integration object with all factors and objectives
  test = integration(all_objectives, all_factors);

  # storeLosses = test.optimize(100, 10e-6, "./losses")
  storeLosses = test.optimize(max_iter, delta_min, "./losses")
  print("\n\nlosses[0]:", storeLosses[:,0], "\nlosses[-1]:", storeLosses[:,-1], "\ndelta loss:", storeLosses[:,0] - storeLosses[:,-1])
  print("\nWhole process finished in ", time.time() - start)
  return shared_fact

# --------------------------------------------------------------
# MAIN

# get parameters
args = sys.argv[1:]; print("args", args)
op_dir, max_iter, delta_min = args[0], int(args[1]), float(args[2])

print("\n*************************\nInit PyNmf.py")
facts = pickle.load(open("./facts.pkl", "rb"))
print("facts", facts)
# print("type(facts)", type(facts))
# print("type(facts[0])", type(facts[0]))
# print("facts[0].keys()", facts[0].keys())
shared_fact = execute_nmf(facts, max_iter, delta_min)
print("shared_fact", shared_fact)
print("facts", facts)
# the factorization matrices' name was updated, we need to pkl.dump with protocol=2
pickle.dump(facts, open("./facts.pkl", "wb"), protocol=2)



""" # ------------------------------------------------------------
### compute the iCell

# get other nmfif parameters
nmfif_params = pickle.load(open("./nmfif_params.pkl", "rb"))
print("nmfif_params", nmfif_params)
# compute iCell if set
if nmfif_params["setup"] == "icell" and shared_fact is not None:
  # compute icell
  print("computing iCell")
  # icell = shared_fact.weights @ shared_fact.weights.T
  import subprocess
  #shared_fact.name + "'"
  # run real command
  command = "bash ../../scripts/include/icell/icell_shell_script.sh breast-cancer_iCell_genelist.csv breast-cancer_G.csv" 
  print("command", command)
  process = subprocess.Popen(command.split(), stdout=subprocess.PIPE)
  output, error = process.communicate()
  print("output", output)
  if error:
    print("error", error)
  # save iCell
  # with h5py.File("iCell", "w") as data_file:
  #     data_file.create_dataset("dataset", data= icell)
  # print("iCell created")
else:
  print("iCell not computed")
"""

""" # ------------------------------------------------------------
### old nmfif version

if False:
  ### nmf

  # %%time

  print("Hello World!")

  start = time.time()
  # // Reading files in, mind that C++ assumes column-major format which does not always correspond to how the data was generated.
  # // Check that the matrix read is as you expect, the option arma::hdf5_opts::trans perform transposition if it isn't
  # arma::mat X; X.load(arma::hdf5_name("../examples/data/test_333_948","dataset",arma::hdf5_opts::trans));

  data_path = "/home/cj/Downloads/nmfif/examples/data/"

  with h5py.File(data_path + "test_333_948", "r") as f:
        X = np.array(f.get('dataset'))

  n1 = X.shape[0]
  n2 = X.shape[1]
  k = 20;

  print("n1, n2")
  print(n1, ", ", n2)

  # initializer = "random";
  initializer = "tsvd"

  all_factors = []
  # // We first create all the factors and add them to a list
  F = factor("./fact_F",n1,k,initializer); all_factors.append(F);
  G = factor("./fact_G",n2,k,initializer); all_factors.append(G);
  print("Factors initialized in ", time.time() - start)

  all_objectives = []
  # // We then initialize the different objectives and add them to a list
  O = nmfObjective(X, X.shape, F, G, initializer); all_objectives.append(O);
  print("Objectives initialized in ", time.time() - start)

  # // Finally we create an integration object with all factors and objectives
  test = integration(all_objectives, all_factors);
  storeLosses = test.optimize(100, 10e-6, "./losses.h5");
  print("\n\nlosses[0]:", storeLosses[:,0], "\nlosses[-1]:", storeLosses[:,-1], "\ndelta loss:", storeLosses[:,0] - storeLosses[:,-1])
  print("\nWhole process finished in ", time.time() - start)

  ### joint_nmtf

  # %%time

  print("Hello World!")

  start = time.time()
  # // Reading files in, mind that C++ assumes column-major format which does not always correspond to how the data was generated.
  # // Check that the matrix read is as you expect, the option arma::hdf5_opts::trans perform transposition if it isn't
  # arma::mat X; X.load(arma::hdf5_name("../data/test_204_948","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_204_948", "r") as f:
        X = np.array(f.get('dataset'))
  # arma::mat Y; Y.load(arma::hdf5_name("../data/test_694_204","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_694_204", "r") as f:
        Y = np.array(f.get('dataset'))
  # arma::mat A; A.load(arma::hdf5_name("../data/test_204_204","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_204_204", "r") as f:
        A = np.array(f.get('dataset'))
  print("Data read in ", time.time() - start)


  n1 = X.shape[0]
  n2 = X.shape[1]
  n3 = Y.shape[0]
  k1 = 20;
  k2 = 50;
  k3 = 73;

  print("n1, n2, n3")
  print(n1, ", ", n2, ", ", n3)

  # initializer = "random";
  initializer = "tsvd"

  all_factors = []
  # // We first create all the factors and add them to a list
  F = factor("./fact_F",n1,k1,initializer); F.addGraphRegularizer(A, 1.0); all_factors.append(F);
  S1 = factor("./fact_S1",k1,k2,initializer); all_factors.append(S1);
  G = factor("./fact_G",n2,k2,initializer); all_factors.append(G);
  S2 = factor("./fact_S2",k3,k1,initializer); all_factors.append(S2);
  H = factor("./fact_H",n3,k3,initializer); all_factors.append(H);
  print("Factors initialized in ", time.time() - start)

  all_objectives = []
  # // We then initialize the different objectives and add them to a list
  O1 = nmtfObjective(X, X.shape, F, S1, G, initializer); all_objectives.append(O1);
  O2 = nmtfObjective(Y, Y.shape, H, S2, F, initializer); all_objectives.append(O2);
  print("Objectives initialized in ", time.time() - start)

  # // Finally we create an integration object with all factors and objectives
  test = integration(all_objectives, all_factors);
  storeLosses = test.optimize(100, 10e-6, "./losses.h5");
  print("\n\nlosses[0]:", storeLosses[:,0], "\nlosses[-1]:", storeLosses[:,-1], "\ndelta loss:", storeLosses[:,0] - storeLosses[:,-1])
  print("\nWhole process finished in ", time.time() - start)

  ### mixed_nmf

  # %%time

  print("Hello World!")

  start = time.time()
  # // Reading files in, mind that C++ assumes column-major format which does not always correspond to how the data was generated.
  # // Check that the matrix read is as you expect, the option arma::hdf5_opts::trans perform transposition if it isn't
  # arma::mat X; X.load(arma::hdf5_name("../data/test_204_948","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_204_948", "r") as f:
        X = np.array(f.get('dataset'))
  # arma::mat Y; Y.load(arma::hdf5_name("../data/test_694_204","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_694_204", "r") as f:
        Y = np.array(f.get('dataset'))
  # arma::mat A; A.load(arma::hdf5_name("../data/test_204_204","dataset",arma::hdf5_opts::trans));
  with h5py.File(data_path + "test_204_204", "r") as f:
        Z = np.array(f.get('dataset'))
  print("Data read in ", time.time() - start)

  n1 = X.shape[0]
  n2 = X.shape[1]
  n3 = Y.shape[0]
  k1 = 20;
  k2 = 50;
  k3 = 73;

  print("n1, n2, n3")
  print(n1, ", ", n2, ", ", n3)

  # initializer = "random";
  initializer = "tsvd"

  all_factors = []
  # // We first create all the factors and add them to a list
  F = factor("./fact_F",n1,k1,initializer); all_factors.append(F);
  S1 = factor("./fact_S1",k1,k2,initializer); all_factors.append(S1);
  G = factor("./fact_G",n2,k2,initializer); G.addL2Regularizer(); all_factors.append(G);
  S2 = factor("./fact_S2",k3,k1,initializer); all_factors.append(S2);
  H = factor("./fact_H",n3,k3,initializer); all_factors.append(H);
  print("Factors initialized in ", time.time() - start)

  all_objectives = []
  # // We then initialize the different objectives and add them to a list
  O1 = nmtfObjective(X, X.shape, F, S1, G, initializer); all_objectives.append(O1);
  O2 = nmtfObjective(Y, Y.shape, H, S2, F, initializer); all_objectives.append(O2);
  O3 = snmfObjective(Z, Z.shape, F, initializer); all_objectives.append(O3);
  print("Objectives initialized in ", time.time() - start)

  # // Finally we create an integration object with all factors and objectives
  test = integration(all_objectives, all_factors);
  storeLosses = test.optimize(100, 10e-6, "./losses.h5");
  print("\n\nlosses[0]:", storeLosses[:,0], "\nlosses[-1]:", storeLosses[:,-1], "\ndelta loss:", storeLosses[:,0] - storeLosses[:,-1])
  print("\nWhole process finished in ", time.time() - start) 
  """